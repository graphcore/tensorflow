/* Copyright 2021 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
#ifndef TENSORFLOW_COMPILER_PLUGIN_POPLAR_DRIVER_POPLAR_EXECUTABLE_CACHE_H_
#define TENSORFLOW_COMPILER_PLUGIN_POPLAR_DRIVER_POPLAR_EXECUTABLE_CACHE_H_

#include <memory>
#include <mutex>

#include <poplar/Engine.hpp>

#include "absl/container/flat_hash_map.h"
#include "tensorflow/compiler/plugin/poplar/driver/poplar_executable.h"
#include "tensorflow/compiler/xla/statusor.h"

namespace xla {
class HloModule;
namespace poplarplugin {
class PoplarExecutor;

using CompileFunction =
    std::function<StatusOr<std::unique_ptr<PoplarExecutableCore>>(
        HloModule*, PoplarExecutor*, uint64)>;

// Cache for compiled Poplar core executables.
//
// Each key is a function which identifies a unique XLA computation and the IPU
// system configuration it was compiled with and the device ordinal it is being
// compiled for, and the value is executable generated by compiling the
// computation.
//
// The cache is implemented as a singleton which means that the core executables
// can be shared for executables being compiled in different sessions.
//
// When an executable is generated by GetOrCompileExecutable, the
// PoplarExecutableCore part of the executable (the part which can be shared) is
// stored in the cache and the compiled PoplarExecutable has a weak reference to
// a PoplarExecutableCore.
//
// The choice of the key means that PoplarExecutableCore can only be shared when
// compiling for the same device ordinal - this is required because the compiled
// Poplar Engine is not thread safe and it cannot be shared between multiple
// runtimes executing concurrently.
//
// This class is threadsafe - if there are parallel compilation requests for the
// same hash key, only a single PoplarExecutableCore will be compiled whilst
// other threads wait.
//
// Note that a PoplarExecutable stores a shared ptr to PoplarExecutableCore,
// once all of these are destroyed, the weak reference in the cache will become
// expired. If the executable is required again then it will be recompiled from
// scratch.
class PoplarExecutableCache {
 public:
  static PoplarExecutableCache& GetInstance();

  // Creates a PoplarExecutable given a module and the executor. The
  // `compile_fn` is called if a PoplarExecutableCore has not been compiled yet.
  StatusOr<std::unique_ptr<PoplarExecutable>> GetOrCompileExecutable(
      std::unique_ptr<HloModule> hlo_module,
      std::unique_ptr<HloProfilePrinterData> hlo_profile_printer,
      std::unique_ptr<HloProfileIndexMap> hlo_profile_index_map,
      PoplarExecutor* executor, CompileFunction compile_fn);

 private:
  PoplarExecutableCache() = default;

  class Entry {
   public:
    Entry() = default;
    std::mutex& GetCompilationMutex();

    Status SetPoplarExecutableCore(
        std::shared_ptr<PoplarExecutableCore>& executable_core)
        EXCLUSIVE_LOCKS_REQUIRED(compilation_mu_);
    std::shared_ptr<PoplarExecutableCore> TryGetPoplarExecutableCore() const
        EXCLUSIVE_LOCKS_REQUIRED(compilation_mu_);

   private:
    std::mutex compilation_mu_;
    std::weak_ptr<PoplarExecutableCore> executable_core_;

    TF_DISALLOW_COPY_AND_ASSIGN(Entry);
  };

  std::mutex cache_mu_;
  absl::flat_hash_map<uint64, std::unique_ptr<Entry>> cache_
      GUARDED_BY(cache_mu_);
};

}  // namespace poplarplugin
}  // namespace xla

#endif  // TENSORFLOW_COMPILER_PLUGIN_POPLAR_DRIVER_POPLAR_EXECUTABLE_CACHE_H_
